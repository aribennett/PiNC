import CppHeaderParser
from struct import calcsize

type_map = {
    'uint8_t': 'B',
    'uint16_t': 'H',
    'uint32_t': 'L',
    'int32_t': 'l',
    'float': 'f',
    'char': 's',
}

defines = {}


header = CppHeaderParser.CppHeader("../../firmware/libraries/SerialClient/SerialClient.h")
print("DEFINES")
for define in header.defines:
    if ' ' in define:
        split_define = define.split(' ')
        defines[split_define[0]] = split_define[1]

print(defines)

print("ENUMS")
print(header.enums)
print("STRUCTS")

tuple_list = []
format_list = []
name_list = []
for packet_class in header.classes:
    if "Packet" in packet_class:
        format_string = '='
        named_tuple = f"namedtuple('{packet_class}', '"
        for prop in header.classes[packet_class]['properties']['public']:
            print(prop)
            if 'array_size' in prop:
                format_string += defines[prop['array_size']]
            format_string += type_map[prop['type']]
            named_tuple += prop['name'] + ' '
        
        type_map[packet_class] = format_string[1:]
        named_tuple += "')"
        tuple_list.append(named_tuple)
        format_list.append(format_string)
        name_list.append(packet_class)
        print(format_string, named_tuple)
        # break

with open('serial_host/packet_definitions.py', 'w') as f:
    f.write("""# Autogenerated Packet definitions. See generate_header.py
from collections import namedtuple
from struct import unpack, pack

""")
    for tup, name in zip(tuple_list, name_list):
        f.write(f'{name} = {tup}\n')
    for format, name in zip(format_list, name_list):
        f.write(f'size_{name} = {calcsize(format)}\n')
    for format, name in zip(format_list, name_list):
        f.write(f"""
def unpack_{name}(bytes):
    return {name}._make(unpack('{format}',bytes))
""")
